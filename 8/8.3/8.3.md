# 8.3. Actualización periódica de datos

## Módulo 1: Proceso Productivo

Una excelente candidata para un proceso batch es la tabla ProcesosRecurrente, que gestiona las distintas etapas de producción de un lote. Se puede implementar un proceso automático diario que revise los registros con estado `En Proceso` y actualice su estado a `Retirado` si ya ha pasado el tiempo estimado de duración del proceso. Esto permite identificar cuellos de botella o retrasos en la línea de producción de forma oportuna, facilitando la toma de decisiones correctivas.

**LÓGICA DEL PROCESO BATCH (Procesos vencidos)**

Cada proceso recurrente tiene una fecha de inicio (`fecha_proceso`) y una duración estimada (`tiempo_proceso` en minutos).

Si la fecha y hora actual ya superó el tiempo estimado desde el inicio y el estado sigue siendo `En Proceso`, entonces el proceso se considera vencido y se debe actualizar su estado a `Retirado`.

**Requisitos previos**
La tabla ProcesosRecurrente ya incluye:
```sql
id_proceso_recurrente SERIAL PRIMARY KEY,
id_lote_producto INT NOT NULL,
numero_batch VARCHAR(20) NOT NULL,
estado VARCHAR(15) CHECK (estado IN ('Completado', 'En inspeccion', 'En proceso', 'Retirado')),
fecha_proceso TIMESTAMP NOT NULL,
tiempo_proceso INT NOT NULL
```
**SCRIPT SQL: Proceso batch diario con cursor**

```sql
CREATE OR REPLACE FUNCTION marcar_procesos_vencidos()
RETURNS VOID AS $$
DECLARE
    reg RECORD;
BEGIN
    FOR reg IN
        SELECT id_proceso_recurrente
        FROM ProcesosRecurrente
        WHERE estado = 'En proceso'
          AND fecha_proceso + (tiempo_proceso || ' minutes')::INTERVAL < CURRENT_TIMESTAMP
    LOOP
        UPDATE ProcesosRecurrente
        SET estado = 'Retirado'
        WHERE id_proceso_recurrente = reg.id_proceso_recurrente;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```
Este caso es ideal para automatización, ya que permite detectar retrasos en tiempo real dentro del flujo de producción. Implementar este proceso como una tarea programada diaria ayuda a mantener el control operativo y a tomar decisiones correctivas de forma oportuna.

**Ventajas de hacerlo con cursor:**
- Permite agregar lógica más compleja para cada proceso individual.
- Se puede extender fácilmente para registrar logs, notificaciones o condiciones especiales por etapa.
- Ideal si más adelante se requiere procesamiento personalizado por evento de producción.

  ## Módulo 2: Almacen de Insumos

**Lógica del Proceso Batch: Actualización Automática de Estados de Entrega**
Este proceso se ejecuta de forma periódica para actualizar automáticamente el estado de entrega de las órdenes de compra en base a criterios de cumplimiento: llegada del insumo a la empresa y validación del control de calidad correspondiente. El objetivo es evitar actualizaciones manuales por parte del personal de almacén y mantener una trazabilidad precisa del estado logístico.

El desafío técnico radica en que la recepción de insumos no ocurre en horarios fijos ni con una frecuencia constante, por lo que no es viable usar triggers como mecanismo de actualización. En su lugar, se propone el uso de una herramienta como pg_cron, que permite programar la ejecución de una función cada cierto número de horas. Esta función verifica qué órdenes han cumplido las condiciones necesarias para avanzar en su estado y actualiza automáticamente el registro, asegurando consistencia en el proceso de abastecimiento.

**SCRIPT SQL: Proceso batch cada 4 horas**
```sql
CREATE OR REPLACE PROCEDURE actualizar_estado_recepciones()
LANGUAGE plpgsql
AS $$
DECLARE
    recep RECORD;
BEGIN
    FOR recep IN
		select id_recepcion 
		from recepciones  
		where not(estado = 'Recepcionado')
    LOOP
        IF EXISTS (select 1 from recepciones r join lotesinsumo l on l.id_recepcion = r.id_recepcion 
				where 
				l.fecha_hora_ingreso_lab is not null and 
				r.id_recepcion = recep.id_recepcion and
				r.estado = 'En entrega') 
		THEN
			UPDATE Recepciones
	       	SET estado = 'Proceso de Calidad'
	     	WHERE id_recepcion = recep.id_recepcion;

		ELSIF NOT EXISTS (select 1 from recepciones r join lotesinsumo l on l.id_recepcion = r.id_recepcion 
					where 
					l.estado_lote_insumo is null and 
					r.id_recepcion = recep.id_recepcion and 
					r.estado = 'Proceso de Calidad')
		THEN 
			UPDATE Recepciones
	       	SET estado = 'A recepcionar'
	     	WHERE id_recepcion = recep.id_recepcion;
		END IF;
    END LOOP;
END;
$$;

-- Activar extensión si no está habilitada
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Programación diaria a las 23:00
SELECT cron.schedule(
  'Actualizar Estados Entrega',
  '0 */4 * * *',  -- cada 4 horas
  $$CALL actualizar_estado_recepciones();$$
);
```

## Módulo 3: Control de Calidad

**Escenario:**
Cada fin de mes, se requiere calcular un resumen de inspecciones con su tasa de rechazo por tipo.

**Diseño de la solución:**
Se programa un job que recorra las tablas y genere una tabla resumen mensual.

**Implementación (PostgreSQL + pgAgent):**
```sql
CREATE TABLE ResumenMensualInspecciones (
    mes DATE,
    tipo_inspeccion VARCHAR(30),
    total INT,
    rechazados INT,
    porcentaje_rechazo NUMERIC
);

-- Proceso mensual (ejemplo SQL)
INSERT INTO ResumenMensualInspecciones (mes, tipo_inspeccion, total, rechazados, porcentaje_rechazo)
SELECT 
    DATE_TRUNC('month', fecha_hora_inspeccion) AS mes,
    tipo_inspeccion,
    COUNT(*) AS total,
    COUNT(*) FILTER (WHERE estado_revision = 'Rechazado') AS rechazados,
    ROUND(COUNT(*) FILTER (WHERE estado_revision = 'Rechazado') * 100.0 / COUNT(*), 2) AS porcentaje_rechazo
FROM InspeccionesGenerales
GROUP BY 1, 2;
```

## Módulo 4: Compras

Una excelente candidata para un proceso batch es la tabla SeguimientosCompra, que gestiona el estado de avance de una compra. Ya que se puede implementar un proceso automático diario que revise los seguimientos con estado 'A Tiempo' y actualice a 'Con Retraso' si ha pasado la fecha límite sin completarse.

**LÓGICA DEL PROCESO BATCH (Compras retrasadas)**

- Cada seguimiento de compra tiene una fecha límite de ingreso (`fecha_ingreso_compra`) estimada.

- Si la fecha actual ya pasó y el estado sigue siendo 'A Tiempo', entonces la compra está retrasada y se debe actualizar su estado a 'Con Retraso'.

**Requisitos previos**
La tabla SeguimientosCompra ya incluye:

```sql
id_seguimiento_compra SERIAL PRIMARY KEY,
codigo VARCHAR(8) UNIQUE NOT NULL,
id_compra INT NOT NULL,
fecha_ingreso_compra TIMESTAMP NULL,
estado estado_seguimiento_compra_enum NOT NULL
```

**SCRIPT SQL: Proceso batch diario**

```sql
UPDATE SeguimientosCompra
SET estado = 'Retrasado'
WHERE estado = 'En Proceso'
  AND fecha_ingreso_compra IS NOT NULL
  AND CURRENT_DATE > fecha_ingreso_compra::DATE;
```

Este caso es el mejor ejemplo, ya que tiene fecha límite concreta y usa un estado de seguimiento que cambia según el tiempo, lo cual se adapta perfectamente a tareas programadas automáticas. El resultado es visible y útil para alertar atrasos en el seguimiento de compras.

## Módulo 5.1: Control de Producción


**Lógica del Proceso Batch (Órdenes de Producción Retrasadas)**

Si la fecha actual ya ha pasado la fecha_fin_estimada y la orden no ha finalizado (es decir, fecha_finalizacion es NULL) y su estado aún está como 'En Proceso', entonces se considera que la orden está retrasada y su estado debe actualizarse a 'Con retraso'.

**Requisitos previos**
La tabla OrdenesProduccion ya incluye:

```sql
    id_orden_produccion SERIAL PRIMARY KEY,
    codigo CHAR(8) UNIQUE NOT NULL,
    fecha_emision TIMESTAMP NOT NULL,
    fecha_fin_estimada DATE NOT NULL,
    fecha_finalizacion DATE,
    estado estado_orden_enum NOT NULL,
    id_solicitud_produccion INT ,
    id_empleado INT NOT NULL,
    FOREIGN KEY (id_solicitud_produccion) REFERENCES SolicitudesProduccion(id_solicitud_produccion),
    FOREIGN KEY (id_empleado) REFERENCES Empleados(id_empleado)
```

**SCRIPT SQL: Proceso batch diario**

```sql
UPDATE OrdenesProduccion
SET estado = 'Retrasado'
WHERE estado = 'En Proceso'
  AND fecha_finalizacion IS NULL
  AND CURRENT_DATE > fecha_fin_estimada;
```

## Módulo 5.2: Mantenimiento


**Lógica del Proceso Batch (Órdenes de Mantenimiento Retrasadas)**

Este proceso se ejecuta diariamente para revisar las órdenes de mantenimiento que aún están en estado `'En Proceso'` y cuya **fecha estimada de finalización** ya ha pasado, pero **no se han completado** (`fecha_finalizacion IS NULL`). Estas órdenes deben actualizar su estado a `'Retrasado'`.

**Requisitos previos**
La tabla OrdenesMantenimiento ya incluye:

```sql
    id_orden_mantenimiento SERIAL PRIMARY KEY,
    codigo CHAR(8) UNIQUE NOT NULL,
    fecha_emision TIMESTAMP,
    fecha_fin_estimada DATE,
    fecha_finalizacion DATE,
    estado estado_orden_enum NOT NULL,
    id_empleado INT NOT NULL,
    id_tecnico INT NOT NULL,
    id_solicitud_mantenimiento INT,
    FOREIGN KEY (id_solicitud_mantenimiento) REFERENCES SolicitudesMantenimiento(id_solicitud_mantenimiento),
    FOREIGN KEY (id_empleado) REFERENCES Empleados(id_empleado),
    FOREIGN KEY (id_tecnico) REFERENCES Personas(id_persona)
```

**SCRIPT SQL: Proceso batch diario**

```sql
UPDATE OrdenesMantenimiento
SET estado = 'Retrasado'
WHERE estado = 'En Proceso'
  AND fecha_finalizacion IS NULL
  AND CURRENT_DATE > fecha_fin_estimada;
```

## Módulo 6: Distribución

**Lógica del Proceso Batch: Cálculo de Indicadores de Gestión**

- Este proceso se ejecuta semestralmente para realizar cálculos de indicadores de gestión en base a los registros y detalles de entrega. El objetivo es que los usuarios como el jefe de distribución u otros gerentes tengan acceso a consultas analíticas del área de Distribución.
- El desafío técnico es lograr que este proceso se ejecute automáticamente cada medianoche del fin de semestres (30 de junio o 31 de diciembre). El módulo de distribución se caracteriza por tener correspondencia directa entre sus registros con los pedidos del cliente, es decir, si la frecuencia de pedidos es baja, entonces los registros del área de distribución no son diarios. Es por ello que no se puede usar un TRIGGER como propuesta de solución. Para ello se plantea el uso de otra herramienta como `pg_cron` que pueda hacer la verificación cada noche si debe ejecutarse o no el proceso batch.

**Requisitos previos**
Se debe crear una tabla de reportes que almacene estos resultados del proceso batch:

```sql
    CREATE TABLE IF NOT EXISTS ReportesDistribucion (
    id_reporte            SERIAL PRIMARY KEY,
    periodo_inicio        DATE     NOT NULL,
    periodo_fin           DATE     NOT NULL,
    kpi_nombre            VARCHAR(50) NOT NULL,
    kpi_valor         NUMERIC(5,2) NOT NULL,
    kpi_meta          NUMERIC(5,2) NOT NULL,
    fecha_calculo         TIMESTAMP NOT NULL,
    UNIQUE(periodo_inicio, periodo_fin, kpi_nombre)
    );
```

**SCRIPT SQL: Proceso batch semestral**

```sql
    -- Extensión pg_cron
    CREATE EXTENSION IF NOT EXISTS pg_cron;

    -- Función de validación de fin de semestre (30 de junio o 31 de diciembre)
    CREATE OR REPLACE FUNCTION validacion_semestre()
    RETURNS VOID
    LANGUAGE plpgsql
    AS $$
    DECLARE
        v_mes INT := EXTRACT(MONTH FROM current_date);
        v_dia INT := EXTRACT(DAY FROM current_date);
        v_anio INT := EXTRACT(YEAR FROM current_date);
    BEGIN
        IF v_mes = 6 AND v_dia = 30 THEN
            CALL <Procedimiento Calculo Indicadores>(); -- El procedimiento y los demás detalles están en el archivo 11.2.md
        ELSIF v_mes = 12 AND v_dia = 31 THEN
            CALL <Procedimiento Calculo Indicadores>(); -- El procedimiento y los demás detalles están en el archivo 11.2.md
        END IF;
    END;
    $$;
```
