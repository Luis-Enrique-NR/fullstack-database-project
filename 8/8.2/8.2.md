# 8.2. Manejo de grandes volúmenes de datos
## Módulo 1: Proceso Produccion

Vamos a aplicar particionamiento por rango de fecha sobre la tabla `ProcesosRecurrente`, tomando como base un campo de tipo `DATE` o `TIMESTAMP` que represente cuándo se generó la orden.

Particionar la tabla `ProcesosRecurrente` por año, usando la columna `fecha_proceso`.

**Paso 1: Asegurar que la Columna `fecha_proceso` Existe**

```sql
ALTER TABLE ProcesosRecurrente
ADD COLUMN fecha_proceso TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP;
```

**Paso 2: Redefinir la Tabla como Particionada**

```sql
CREATE TABLE ProcesosRecurrente (
    id_proceso_recurrente SERIAL PRIMARY KEY,
    id_lote_producto INT NOT NULL,
    numero_batch VARCHAR(20) NOT NULL,
    estado estado_proceso_enum NOT NULL,
    fecha_proceso TIMESTAMP NOT NULL,
    tiempo_proceso INT NOT NULL,
    
    FOREIGN KEY (id_lote_producto) REFERENCES LotesProducto(id_lote_producto)
) PARTITION BY RANGE (fecha_proceso);
```

**Paso 3: Crear Particiones por Año**

```sql
CREATE TABLE ProcesosRecurrente_2024 PARTITION OF ProcesosRecurrente
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE ProcesosRecurrente_2025 PARTITION OF ProcesosRecurrente
FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```
## Módulo 2: Almcacen de Insumos

Implementaremos particionamiento por rangos de fecha sobre la tabla `Recepciones`, utilizando una columna de tipo `DATE` o `TIMESTAMP` que indique el momento en que se realizo la recepcion.

Dividiremos la tabla `Recepciones` en particiones anuales basándonos en la columna `fecha_llegada`.

**Paso 1: Asegurar que la Columna `fecha_llegada` Existe**

```sql
ALTER TABLE Recepciones
ADD COLUMN fecha_llegada TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP;
```

**Paso 2: Redefinir la Tabla como Particionada**

```sql
CREATE TABLE Recepciones (
    id_recepcion SERIAL PRIMARY KEY,
    codigo VARCHAR(20) unique not NULL, 
    fecha_llegada TIMESTAMP ,
    estado estado_recepcion_enum ,
    id_compra INT NOT NULL,
    id_empleado INT NOT NULL,
    foreign key (id_compra) references Compras(id_compra),
    foreign key (id_empleado) references Empleados(id_empleado)
) PARTITION BY RANGE (fecha_llegada);
```

**Paso 3: Crear Particiones por Año**

```sql
CREATE TABLE Recepciones_2024 PARTITION OF Recepciones
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE Recepciones_2025 PARTITION OF Recepciones
FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

### Módulo 3: Control de Calidad

**Escenario:**
La tabla `InspeccionesGenerales` acumula miles de registros mensuales por distintos tipos de inspección.

**Diseño de la solución:**
Se propone particionar la tabla por rango de fecha (`fecha_hora_inspeccion`). Esto permite una administración eficiente de grandes volúmenes y consultas más rápidas.

**Implementación (PostgreSQL):**
```sql
-- Tabla padre
CREATE TABLE InspeccionesGenerales (
    id_inspeccion SERIAL PRIMARY KEY,
    codigo VARCHAR(10),
    tipo_inspeccion VARCHAR(30),
    fecha_hora_inspeccion TIMESTAMP,
    estado_revision VARCHAR(20),
    comentario TEXT,
    evidencia TEXT,
    id_empleado INT
) PARTITION BY RANGE (fecha_hora_inspeccion);

-- Ejemplo de partición para enero 2025
CREATE TABLE InspeccionesGenerales_2025_01
PARTITION OF InspeccionesGenerales
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
```

## Módulo 4: Compras

Vamos a aplicar particionamiento por rango de fecha sobre la tabla `OrdenesCompra`, tomando como base un campo de tipo `DATE` o `TIMESTAMP` que represente cuándo se generó la orden.

**Paso 1: Añadir columna de fecha si no existe**

Primero, se necesita una columna como `fecha_emision` o similar en `OrdenesCompra`. Si aún no existe:

```sql
ALTER TABLE OrdenesCompra
ADD COLUMN fecha_emision DATE NOT NULL DEFAULT CURRENT_DATE;
```

**Paso 2: Redefinir la tabla con particionamiento por rango**

Esto requiere crear de nuevo la tabla `OrdenesCompra` como particionada, ya que PostgreSQL no permite convertir una tabla existente directamente a particionada. Sigue este esquema:

```sql
CREATE TABLE OrdenesCompra (
	id_orden_compra SERIAL PRIMARY KEY,
	codigo VARCHAR(8) UNIQUE NOT NULL,
	id_propuesta_compra INT NOT NULL,
	id_empleado INT NOT NULL,
	estado estado_orden_compra_enum NOT NULL,
	fecha_emision DATE NOT NULL,
	
	FOREIGN KEY (id_empleado) REFERENCES Empleados(id_empleado),
	FOREIGN KEY (id_propuesta_compra) REFERENCES PropuestasCompra(id_propuesta_compra)
) PARTITION BY RANGE (fecha_emision);
```

**Paso 3: Crear particiones anuales**

Aquí unos ejemplos para los años 2024 y 2025:

```sql
CREATE TABLE OrdenesCompra_2024 PARTITION OF OrdenesCompra
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE OrdenesCompra_2025 PARTITION OF OrdenesCompra
FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```
## Módulo 5.1: Contol de Producción

A continuación se describe cómo aplicar particionamiento por rango de fechas usando el campo `fecha_emision` (tipo `TIMESTAMP`) en la tabla `OrdenesProduccion` de PostgreSQL.

**Paso 1: Renombrar la tabla original**

Como ya existe la tabla `OrdenesProduccion`, se renombra para conservar los datos:

```sql
ALTER TABLE OrdenesProduccion RENAME TO OrdenesProduccion_backup;
```

**Paso 2: Redefinir la tabla con particionamiento por rango**

Esto requiere crear de nuevo la tabla `OrdenesProduccion` como particionada, ya que PostgreSQL no permite convertir una tabla existente directamente a particionada. Sigue este esquema:

```sql
CREATE TABLE OrdenesProduccion (
    id_orden_produccion SERIAL PRIMARY KEY,
    codigo CHAR(8) UNIQUE NOT NULL,
    fecha_emision TIMESTAMP NOT NULL,
    fecha_fin_estimada DATE NOT NULL,
    fecha_finalizacion DATE,
    estado estado_orden_enum NOT NULL,
    id_solicitud_produccion INT,
    id_empleado INT NOT NULL,
    FOREIGN KEY (id_solicitud_produccion) REFERENCES SolicitudesProduccion(id_solicitud_produccion),
    FOREIGN KEY (id_empleado) REFERENCES Empleados(id_empleado)
) PARTITION BY RANGE (fecha_emision);
```

**Paso 3: Crear particiones anuales**

Aquí unos ejemplos para los años 2024 y 2025:

```sql
CREATE TABLE OrdenesProduccion_2024 PARTITION OF OrdenesProduccion
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE OrdenesProduccion_2025 PARTITION OF OrdenesProduccion
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

## Módulo 5.2: Mantenimiento

A continuación se describe cómo aplicar particionamiento por rango de fechas usando el campo `fecha_emision` (tipo `TIMESTAMP`) en la tabla `OrdenesMantenimiento` de PostgreSQL.

**Paso 1: Renombrar la tabla original**

Como ya existe la tabla `OrdenesMantenimiento`, se renombra para conservar los datos:

```sql
ALTER TABLE OrdenesMantenimiento RENAME TO OrdenesMantenimiento_backup;
```

**Paso 2: Redefinir la tabla con particionamiento por rango**

Esto requiere crear de nuevo la tabla `OrdenesMantenimiento` como particionada, ya que PostgreSQL no permite convertir una tabla existente directamente a particionada. Sigue este esquema:

```sql
CREATE TABLE OrdenesMantenimiento (
    id_orden_mantenimiento SERIAL PRIMARY KEY,
    codigo CHAR(8) UNIQUE NOT NULL,
    fecha_emision TIMESTAMP,
    fecha_fin_estimada DATE,
    fecha_finalizacion DATE,
    estado estado_orden_enum NOT NULL,
    id_empleado INT NOT NULL,
    id_tecnico INT NOT NULL,
    id_solicitud_mantenimiento INT,
    FOREIGN KEY (id_solicitud_mantenimiento) REFERENCES SolicitudesMantenimiento(id_solicitud_mantenimiento),
    FOREIGN KEY (id_empleado) REFERENCES Empleados(id_empleado),
    FOREIGN KEY (id_tecnico) REFERENCES Personas(id_persona)
) PARTITION BY RANGE (fecha_emision);
```

**Paso 3: Crear particiones anuales**

Aquí unos ejemplos para los años 2024 y 2025:

```sql
CREATE TABLE OrdenesMantenimiento_2024 PARTITION OF OrdenesMantenimiento
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE OrdenesMantenimiento_2025 PARTITION OF OrdenesMantenimiento
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

## Módulo 6: Distribución

A continuación se describe cómo aplicar particionamiento por rango de fechas usando el campo `fecha_prog_salida` (tipo `TIMESTAMP`) en la tabla `ProgramacionesDespacho` de PostgreSQL.

**Paso 1: Renombrar la tabla original**

Como ya existe la tabla `ProgramacionesDespacho`, se renombra para conservar los datos:

```sql
ALTER TABLE ProgramacionesDespacho RENAME TO ProgramacionesDespacho_backup;
```

**Paso 2: Redefinir la tabla con particionamiento por rango**

Esto requiere crear de nuevo la tabla `ProgramacionesDespacho` como particionada, ya que PostgreSQL no permite convertir una tabla existente directamente a particionada. Sigue este esquema:

```sql
CREATE TABLE ProgramacionesDespacho (
    id_prog_desp SERIAL PRIMARY KEY,
    id_transportista INT,
    id_vehiculo INT,
    id_empleado INT NOT NULL,
    codigo CHAR(8) NOT NULL UNIQUE,
    tipo_servicio tipo_servicio_enum,
    fecha_prog_salida TIMESTAMP NOT NULL,
    fecha_programacion TIMESTAMP NOT NULL,
    FOREIGN KEY (id_transportista) REFERENCES Transportistas(id_transportista),
    FOREIGN KEY (id_vehiculo) REFERENCES Vehiculos(id_vehiculo),
    FOREIGN KEY (id_empleado) REFERENCES Empleados(id_empleado)
) PARTITION BY RANGE (fecha_prog_salida);
```

**Paso 3: Crear particiones anuales**

Aquí unos ejemplos para los años 2024 y 2025:

```sql
CREATE TABLE ProgramacionesDespacho_2024 PARTITION OF ProgramacionesDespacho
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE ProgramacionesDespacho_2025 PARTITION OF ProgramacionesDespacho
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```
