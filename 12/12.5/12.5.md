# 12.5. Arquitectura Backend

## 1. Visión general
El backend se organiza por módulos de negocio (almacén, calidad, compras, distribución, mantenimiento, producción) y por capas bien delimitadas. La lógica de negocio se concentra en application/service, los controladores exponen la API HTTP y los repositorios realizan acceso a datos. El flujo se apoya en DTOs por capa y mappers.

## 2. Responsabilidades por capa

### 2.1 Presentation
- Controllers REST por módulo (presentation.controller.rest.{modulo}).
- Recepción y validación de DTOs de presentación (entrada/salida).
- Gestión uniforme de respuestas mediante ApiResponse<T>.
- Enrutamiento y semántica HTTP (GET/POST/PUT/PATCH/DELETE) según el caso de uso.

### 2.2 Application
- Services por módulo: orquestación de casos de uso y reglas de negocio.
- DTOs de aplicación (comando/consulta) cuando el caso lo requiere.
- Mappers entre capas (presentación ↔ aplicación ↔ entidad), con soporte para actualizaciones parciales.

### 2.3 Domain
- Entities mapeadas a la persistencia.
- Excepciones de dominio tipificadas para control de flujo y mensajes.

### 2.4 Infrastructure
- Repositories con Spring Data JPA.

### 2.5 Shared
- Utilidades transversales (p. ej., ApiResponse).

## 3. Ciclo de una solicitud
HTTP → Controller (Presentation DTO) 
     → Mapper 
     → Service (Application DTO o Entity)
     → Repository (Entity)
     → Mapper 
     → Controller (ApiResponse<Presentation DTO>) → HTTP

1. El controller recibe la petición y materializa un DTO de presentación.
2. El mapper traduce al contrato interno (Application DTO) o directamente a Entity, según la complejidad.
3. El service ejecuta el caso de uso (reglas de negocio y orquestación).
4. El repository realiza I/O con la BD.
5. El mapper prepara el DTO de salida y el controller responde con ApiResponse.


## 4. DTOs y Mappers

### 4.1 Tipos de DTO
Presentación (API): contrato externo del endpoint (entrada/salida).
Aplicación (interno): comando/consulta para orquestación del caso de uso cuando aporta claridad.
Entity: representación persistente (no se expone por la API).

### 4.2 Mappers
Ubicación: application.mapper.
Implementación con builder/conversión explícita.
Soporte de update parcial: los campos null no sobrescriben valores existentes (uso de Optional)

## 5. Servicios y transacciones
Ubicación: application.service.{modulo}.
Punto de control transaccional con @Transactional a nivel de método de servicio.
Validaciones de negocio y reglas de consistencia se aplican aquí.
Interacción con repositorios y composición de respuestas para la capa de presentación.
