# 11.2. Especificación de Procesos Batch

## Módulo 1: Proceso Productivo

### Objetivo del Proceso

Identificar y actualizar automáticamente los procesos de producción que han excedido su tiempo estimado de ejecución y que aún se encuentran en estado `"En proceso"`, marcándolos como `"Retirado"`.
Este proceso permite:

* Controlar la eficiencia operativa de la línea de producción.
* Evitar cuellos de botella.

### Datos de Entrada

**Tablas involucradas:**

* `Dosificados(id_dosificado, id_lote, fecha_inicio, estado)`
* `Mezclados(id_mezclado, id_lote, fecha_inicio, estado)`
* `Moldeados(id_moldeado, id_lote, fecha_inicio, estado)`
* `Secados(id_secado, id_lote, fecha_inicio, estado)`
* `Envasados(id_envasado, id_lote, fecha_inicio, estado)`

**Condiciones:**

* Estado actual del proceso: `"En proceso"`.
* Tiempo transcurrido desde `fecha_inicio` mayor al tiempo estimado (según tipo de proceso).

### Operaciones Realizadas

1. Por cada tipo de proceso (Dosificado, Mezclado, etc.):

   * Se recorre mediante un **bucle** los registros con estado `"En proceso"`.
   * Se compara `fecha_inicio + tiempo_estimado` vs. `NOW()`.
   * Si ya venció el tiempo, se actualiza el estado a `"Retirado"`.
2. Se contabilizan los procesos retirados por tipo.
3. Se registra un resumen en la tabla `ReporteProcesosRetirados`.

### Datos de Salida

Actualización de estados + inserción en la siguiente tabla de resumen:

```sql
CREATE TABLE IF NOT EXISTS ReporteProcesosRetirados (
  id_reporte         SERIAL PRIMARY KEY,
  fecha_ejecucion    TIMESTAMP NOT NULL,
  total_retirados    INT       NOT NULL,
  tipo_proceso       VARCHAR(30) NOT NULL
);
```
### Implementación en PL/pgSQL

```sql
CREATE OR REPLACE PROCEDURE batch_retirar_procesos_excedidos()
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  contador INT;
  total_retirados INT := 0;

  procesos TEXT[][] := ARRAY[
    ['Dosificados', 'id_dosificado', '2 hours'],
    ['Mezclados',   'id_mezclado',   '3 hours'],
    ['Moldeados',   'id_moldeado',   '2 hours'],
    ['Secados',     'id_secado',     '5 hours'],
    ['Envasados',   'id_envasado',   '2 hours']
  ];

  i INT := 1;
BEGIN
  WHILE i <= array_length(procesos, 1) LOOP
    contador := 0;

    FOR rec IN
      EXECUTE format(
        'SELECT %I AS id, fecha_inicio FROM %I
         WHERE estado = %L AND fecha_inicio + interval %L < now()',
         procesos[i][2], procesos[i][1], 'En proceso', procesos[i][3]
      )
    LOOP
      EXECUTE format(
        'UPDATE %I SET estado = %L WHERE %I = $1',
        procesos[i][1], 'Retirado', procesos[i][2]
      )
      USING rec.id;

      contador := contador + 1;
    END LOOP;

    IF contador > 0 THEN
      INSERT INTO ReporteProcesosRetirados (fecha_ejecucion, total_retirados, tipo_proceso)
      VALUES (NOW(), contador, procesos[i][1]);
    END IF;

    i := i + 1;
  END LOOP;
END;
$$;
```

### Frecuencia de Ejecución

Este proceso debe ejecutarse automáticamente cada día al finalizar la jornada de producción.

Requiere: `pg_cron`

```sql
-- Activar extensión si no está habilitada
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Programación diaria a las 23:00
SELECT cron.schedule(
  'batch_retiro_procesos_excedidos',
  '0 23 * * *',
  $$CALL batch_retirar_procesos_excedidos();$$
);
```
## Módulo 2: Almacen de Insumos

### Proceso Batch PB-201: Actualizacion de los estados de orden compra

**Escenario:**
El módulo de Almacén de Insumos requiere que los estados de entrega de las órdenes de compra se actualicen automáticamente en función del cumplimiento de llegada del pedido a la empresa y la validación del proceso de control de calidad, sin intervención manual, para reflejar correctamente el avance logístico.

**Diseño de la solución:**
Se programa, con la extensión de pg_cron, que periódicamente se ejecute una función que verifique si una orden de compra ya fue recibida por la empresa y si pasó por el proceso de calidad. Según estos criterios, se actualiza automáticamente su estado de entrega para mantener el flujo operativo actualizado.


**Sentencias SQL:**

```sql
CREATE OR REPLACE PROCEDURE actualizar_estado_recepciones()
LANGUAGE plpgsql
AS $$
DECLARE
    recep RECORD;
BEGIN
    FOR recep IN
		select id_recepcion 
		from recepciones  
		where not(estado = 'Recepcionado')
    LOOP
        IF EXISTS (select 1 from recepciones r join lotesinsumo l on l.id_recepcion = r.id_recepcion 
				where 
				l.fecha_hora_ingreso_lab is not null and 
				r.id_recepcion = recep.id_recepcion and
				r.estado = 'En entrega') 
		THEN
			UPDATE Recepciones
	       	SET estado = 'Proceso de Calidad'
	     	WHERE id_recepcion = recep.id_recepcion;

		ELSIF NOT EXISTS (select 1 from recepciones r join lotesinsumo l on l.id_recepcion = r.id_recepcion 
					where 
					l.estado_lote_insumo is null and 
					r.id_recepcion = recep.id_recepcion and 
					r.estado = 'Proceso de Calidad')
		THEN 
			UPDATE Recepciones
	       	SET estado = 'A recepcionar'
	     	WHERE id_recepcion = recep.id_recepcion;
		END IF;
    END LOOP;
END;
$$;

-- Activar extensión si no está habilitada
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Programación diaria a las 23:00
SELECT cron.schedule(
  'Actualizar Estados Entrega',
  '0 */4 * * *',  -- cada 4 horas
  $$CALL actualizar_estado_recepciones();$$
);
```

## Módulo 3: Control de Calidad

### Objetivo del Proceso

Mantener actualizada la vista materializada `mv_inspecciones_por_dia`, la cual resume el número de inspecciones registradas por día y tipo.  Tener esta vista actualizada permite consultas rápidas desde el módulo de historial de inspecciones.

### Datos de Entrada

**Tabla base:** `InspeccionesGenerales`.

**Vista a actualizar:** `mv_inspecciones_por_dia`.

### Operaciones Realizadas

1. Ejecutar `REFRESH MATERIALIZED VIEW CONCURRENTLY mv_inspecciones_por_dia;` para regenerar los datos de la vista según la información más reciente de `InspeccionesGenerales`.

### Datos de Salida

La vista `mv_inspecciones_por_dia` queda actualizada con el total de inspecciones por fecha y tipo.

### Implementación en PL/pgSQL

```sql
CREATE OR REPLACE PROCEDURE refrescar_resumen_diario_inspecciones()
LANGUAGE plpgsql
AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_inspecciones_por_dia;
END;
$$;
```

### Frecuencia de Ejecución

Se recomienda programar este procedimiento una vez al día, por ejemplo a las 22:00, empleando la extensión `pg_cron`:

```sql
CREATE EXTENSION IF NOT EXISTS pg_cron;

SELECT cron.schedule(
  'batch_resumen_diario_inspecciones',
  '0 22 * * *',
  $$CALL refrescar_resumen_diario_inspecciones();$$
);
```


## Módulo 5: Control de Producción

### Objetivo del Proceso

Actualizar automáticamente el estado de los lotes de producción en el sistema, verificando si todos los procesos asociados al lote han sido completados. Si es así, el lote se marcará como `"Completado"`.  
Esto permite:

* Mantener actualizada la trazabilidad de la producción.
* Facilitar la supervisión y la planificación de la producción.
* Evitar retrasos por lotes pendientes de cierre administrativo.

### Datos de Entrada

**Tablas involucradas:**

* `Lotes(id_lote, codigo_lote, estado)`
* `Dosificados(id_dosificado, id_lote, estado)`
* `Mezclados(id_mezclado, id_lote, estado)`
* `Moldeados(id_moldeado, id_lote, estado)`
* `Secados(id_secado, id_lote, estado)`
* `Envasados(id_envasado, id_lote, estado)`

**Condiciones:**

* Lotes cuyo estado actual es `"En proceso"`.
* Todos los procesos asociados al lote (`Dosificados`, `Mezclados`, `Moldeados`, `Secados`, `Envasados`) tienen estado `"Completado"`.

### Operaciones Realizadas

1. Se recorre la tabla de `Lotes` con estado `"En proceso"`.
2. Para cada lote, se valida que todos los procesos asociados tengan estado `"Completado"`.
3. Si se cumple la condición, se actualiza el lote a estado `"Completado"`.
4. Se registra un resumen de los lotes actualizados en la tabla `ReporteLotesCompletados`.

### Datos de Salida

Actualización de estado en la tabla `Lotes` y registro de la operación en la siguiente tabla de resumen:

```sql
CREATE TABLE IF NOT EXISTS ReporteLotesCompletados (
  id_reporte         SERIAL PRIMARY KEY,
  fecha_ejecucion    TIMESTAMP NOT NULL,
  total_lotes        INT       NOT NULL
);
```

### Implementación en PL/pgSQL

```sql
CREATE OR REPLACE PROCEDURE batch_actualizar_lotes_completados()
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  contador INT := 0;
BEGIN
  FOR rec IN
    SELECT l.id_lote
    FROM Lotes l
    WHERE l.estado = 'En proceso'
      AND NOT EXISTS (
        SELECT 1 FROM Dosificados d WHERE d.id_lote = l.id_lote AND d.estado <> 'Completado'
        UNION
        SELECT 1 FROM Mezclados m WHERE m.id_lote = l.id_lote AND m.estado <> 'Completado'
        UNION
        SELECT 1 FROM Moldeados mo WHERE mo.id_lote = l.id_lote AND mo.estado <> 'Completado'
        UNION
        SELECT 1 FROM Secados s WHERE s.id_lote = l.id_lote AND s.estado <> 'Completado'
        UNION
        SELECT 1 FROM Envasados e WHERE e.id_lote = l.id_lote AND e.estado <> 'Completado'
      )
  LOOP
    UPDATE Lotes SET estado = 'Completado' WHERE id_lote = rec.id_lote;
    contador := contador + 1;
  END LOOP;

  IF contador > 0 THEN
    INSERT INTO ReporteLotesCompletados (fecha_ejecucion, total_lotes)
    VALUES (NOW(), contador);
  END IF;
END;
$$;
```

### Frecuencia de Ejecución

Este proceso debe ejecutarse automáticamente cada día al finalizar la jornada de producción.

Requiere: `pg_cron`

```sql
-- Activar extensión si no está habilitada
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Programación diaria a las 23:00
SELECT cron.schedule(
  'batch_actualizar_lotes_completados',
  '0 23 * * *',
  $$CALL batch_actualizar_lotes_completados();$$
);
```

## Módulo 4: Compras

### Proceso Batch PB-401: Actualización de Reclamos Pendientes Vencidos

**Objetivo**

Actualizar automáticamente el estado de los reclamos que permanecen en estado 'Pendiente' pero que han superado su fecha límite de atención. Esto permitirá identificar de forma automática aquellos reclamos que han sido ignorados o postergados, marcándolos como 'Con Retraso' (vencido), lo que facilita la gestión y control del área de calidad y abastecimiento.

**Datos de Entrada**

Tabla: Reclamos

Columnas relevantes:

  `id_reclamo`

  `estado_reclamo`

  `fecha_reclamo`

  `dias_maximo_respuesta`

**Operaciones Realizadas**

Se calcula la fecha límite sumando dias_maximo_respuesta a la fecha_reclamo.

Si la fecha límite es menor que la fecha actual y el estado del reclamo es 'Pendiente', se cambia automáticamente a 'Con Retraso'.

El proceso recorre todos los reclamos pendientes (estado_reclamo = 'Pendiente') y actualiza los que estén vencidos.

**Salida**

Los reclamos vencidos son actualizados en su columna estado_reclamo, pasando de 'Pendiente' a 'Con Retraso'.

```sql

CREATE OR REPLACE PROCEDURE actualizar_reclamos_vencidos()
LANGUAGE plpgsql AS $$
DECLARE
    reclamo RECORD;
BEGIN
    FOR reclamo IN
        SELECT id_reclamo, fecha_reclamo, dias_maximo_respuesta
        FROM Reclamos
        WHERE estado_reclamo = 'PEN'
    LOOP
        IF reclamo.fecha_reclamo + (reclamo.dias_maximo_respuesta || ' days')::INTERVAL < CURRENT_DATE THEN
            UPDATE Reclamos
            SET estado_reclamo = 'VEN'
            WHERE id_reclamo = reclamo.id_reclamo;
        END IF;
    END LOOP;
END;
$$;

```

**Ejecución sugerida**

Este procedimiento debe ejecutarse automáticamente una vez al día, preferiblemente durante la madrugada, mediante una tarea programada (por ejemplo, cron job o pgAgent). Esto asegura que los reclamos vencidos se identifiquen sin intervención manual, mejorando la trazabilidad y la eficiencia del proceso de gestión de reclamos.

## Módulo 6: Distribución

### Proceso Batch PB-601: Cálculo de Indicadores de Entrega

**Escenario:**
Cada fin de semestre, el jefe de distribución y demás directivos requieren un informe con los resultados de los indicadores de gestión respecto a las entregas de los pedidos.

**Diseño de la solución:**
Se programa, con la extensión de `pg_cron`, que cada fin de semestre (30 de junio o 31 de diciembre) se ejecuten funciones para poblar la tabla de `ReportesDistribucion` de acuerdo a detalles de entrega para realizar consultas analíticas de los indicadores de gestión.

**Sentencias SQL:**

```sql
-- 1. Creación de la Tabla de Salida:
CREATE TABLE IF NOT EXISTS ReportesDistribucion (
  id_reporte            SERIAL PRIMARY KEY,
  periodo_inicio        DATE     NOT NULL,
  periodo_fin           DATE     NOT NULL,
  kpi_nombre            VARCHAR(100) NOT NULL,
  kpi_valor         NUMERIC(5,2) NOT NULL,
  kpi_meta          NUMERIC(5,2) NOT NULL,
  fecha_calculo         TIMESTAMP NOT NULL,
  UNIQUE(periodo_inicio, periodo_fin, kpi_nombre)
);

-- 2. Creación de la Función de Actualización de Reportes:
CREATE OR REPLACE FUNCTION registrar_reporte (
    pin DATE,
    pf DATE,
    kn VARCHAR,
    kv NUMERIC,
    km NUMERIC
) RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
	IF EXISTS (SELECT 1 FROM ReportesDistribucion WHERE periodo_inicio = pin and periodo_fin = pf and kpi_nombre = kn) THEN
		UPDATE ReportesDistribucion
	       SET kpi_valor = kv,
	           kpi_meta = km,
	           fecha_calculo = current_timestamp
	     WHERE periodo_inicio = pin
	       AND periodo_fin    = pf
	       AND kpi_nombre     = kn;
	ELSE 
		INSERT INTO ReportesDistribucion(
	      periodo_inicio, periodo_fin, kpi_nombre, kpi_valor, kpi_meta)
	    VALUES (pin, pf, kn, kv, km);
	END IF;
	RETURN;
END;
$$;

-- 3. Procedimiento y cálculos de los indicadores
CREATE OR REPLACE PROCEDURE calculo_indicadores_reportes_distribucion(p_inicio DATE, p_fin DATE) 
LANGUAGE plpgsql
AS $$
DECLARE
    v_puntualidad    NUMERIC(5,2);
    v_conformidad    NUMERIC(5,2);
    v_salida_puntual   NUMERIC(5,2);
    -- Metas fijas
    m_puntualidad    CONSTANT NUMERIC(5,2) := 95.00;
    m_conformidad    CONSTANT NUMERIC(5,2) := 95.00;
    m_salida_puntual   CONSTANT NUMERIC(5,2) :=100.00;
BEGIN

  -- KPI 1: Tasa de Entregas Puntuales
	select
	    round(100.0 * sum(case when puntualidad = 'Puntual' then 1 else 0 end) / count(*), 2) as tasa_puntualidad
		into v_puntualidad
	from (
	    select distinct pick.id_pedido_cliente,
	        case
	            when pc.fecha_prog_entrega < date(re.fecha_entrega) then 'Impuntual'
	            else 'Puntual'
	        end as puntualidad
	    from registrosentrega re
	    inner join detallesentrega de
	        on de.id_reg_ent = re.id_reg_ent 
	    inner join detallespicking dpick
	        on dpick.id_picking = de.id_picking and dpick.id_lote_producto = de.id_lote_producto
	    inner join pickings pick
	        on pick.id_picking = dpick.id_picking 
	    inner join pedidoscliente pc
	        on pc.id_pedido_cliente = pick.id_pedido_cliente
	    where pc.fecha_pedido between p_inicio and p_fin
	        and re.id_orden_carga in (
	            select distinct o.id_orden_carga
	            from ordenescarga o 
	            inner join pedidosdespacho p
	                on o.id_prog_desp = p.id_prog_desp 
	            where p.motivo_despacho = 'Entrega'
	        )
	) as sub;

  -- KPI 2: Tasa de Conformidad en la Entrega
	select 
		round(100.0 * sum(case when estado_entrega = 'Conforme' then 1 else 0 end) / count(*), 2) as tasa_conformidad
		into v_conformidad
	from registrosentrega r 
	where r.fecha_entrega between p_inicio and p_fin;

  -- KPI 3: Tasa de Puntualidad en la salida de Ordenes de Carga
	select 
	    round(100.0 * sum(case when puntualidad = 'Puntual' then 1 else 0 end) / count(*), 2) as tasa_salida_puntual_orden_carga
		into v_salida_puntual
	from (
		select 
			o.id_orden_carga,
			case 
				when o.fecha_salida > prog.fecha_prog_salida then 'Impuntual'
				else 'Puntual'
			end as puntualidad
		from ordenescarga o
		inner join programacionesdespacho prog
			on o.id_prog_desp = prog.id_prog_desp 
		where prog.fecha_programacion between p_inicio and p_fin
	) as sub;

	CALL registrar_reporte(p_inicio, p_fin, 'Tasa de Entregas Puntuales', v_puntualidad, m_puntualidad);
	CALL registrar_reporte(p_inicio, p_fin, 'Tasa de Conformidad en la Entrega', v_conformidad,  m_conformidad);
	CALL registrar_reporte(p_inicio, p_fin, 'Tasa de Puntualidad en la salida de Ordenes de Carga', v_salida_puntual, m_salida_puntual);
END;
$$;

-- 4. Programación del proceso batch semestral

-- Extensión pg_cron
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Función de validación de fin de semestre (30 de junio o 31 de diciembre)
CREATE OR REPLACE FUNCTION validacion_semestre()
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
	v_mes INT := EXTRACT(MONTH FROM current_date);
    v_dia INT := EXTRACT(DAY FROM current_date);
    v_anio INT := EXTRACT(YEAR FROM current_date);
BEGIN
    IF v_mes = 6 AND v_dia = 30 THEN
        CALL calculo_indicadores_reportes_distribucion(
            make_date(v_anio, 1, 1),
            current_date
        );

    ELSIF v_mes = 12 AND v_dia = 31 THEN
        CALL calculo_indicadores_reportes_distribucion(
            make_date(v_anio, 7, 1),  -- 1 de julio del año actual
            current_date
        );
    END IF;
END;
$$;

-- Programación de la ejecución de la función todos los días a las 23:59
SELECT cron.schedule(
  'batch_indicadores_distribucion',
  '59 23 * * *',                     
  $$SELECT validacion_semestre_mejorada()$$ 
);
```

---

## Módulo 7: Almacén de Productos Terminados

