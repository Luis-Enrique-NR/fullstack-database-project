# 10.4. Otros objetos de BD

## Módulo 1: Proceso Productivo

### Funciones Trigger

* **Justificación:** Para la generación de códigos de forma automática.

* **Tablas:** `Dosificados`, `Mezclados`, `Moldeados`, `Secados`, `Envasados`

```sql
CREATE OR REPLACE FUNCTION asignar_codigo_dosificado() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.codigo IS NULL THEN
        NEW.codigo := generar_codigo_dosificado();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION asignar_codigo_mezclado() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.codigo IS NULL THEN
        NEW.codigo := generar_codigo_mezclado();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION asignar_codigo_moldeado() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.codigo IS NULL THEN
        NEW.codigo := generar_codigo_moldeado();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION asignar_codigo_secado() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.codigo IS NULL THEN
        NEW.codigo := generar_codigo_secado();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION asignar_codigo_envasado() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.codigo IS NULL THEN
        NEW.codigo := generar_codigo_envasado();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```


### Triggers

* **Justificación:** Para su inserción automática en las tablas correspondientes.

* **Tablas:** `Dosificados`, `Mezclados`, `Moldeados`, `Secados`, `Envasados`

```sql
CREATE TRIGGER trg_insert_dosificado
BEFORE INSERT ON Dosificados
FOR EACH ROW
EXECUTE FUNCTION asignar_codigo_dosificado();

CREATE TRIGGER trg_insert_mezclado
BEFORE INSERT ON Mezclados
FOR EACH ROW
EXECUTE FUNCTION asignar_codigo_mezclado();

CREATE TRIGGER trg_insert_moldeado
BEFORE INSERT ON Moldeados
FOR EACH ROW
EXECUTE FUNCTION asignar_codigo_moldeado();

CREATE TRIGGER trg_insert_secado
BEFORE INSERT ON Secados
FOR EACH ROW
EXECUTE FUNCTION asignar_codigo_secado();

CREATE TRIGGER trg_insert_envasado
BEFORE INSERT ON Envasados
FOR EACH ROW
EXECUTE FUNCTION asignar_codigo_envasado();
```

### Funciones de Consulta

* **Justificación:** Para generar tablas rápidamente bajo la inserción de un único parámetro: código del lote de producto.

```sql
CREATE OR REPLACE FUNCTION encontrar_eventos_lote(codigo_lote TEXT)
RETURNS TABLE (
    "N° Batch" TEXT,
    "Etapa de Producción" TEXT,
    "Estado" TEXT,
    "Fecha y hora de inicio" TIMESTAMP,
    "Tiempo de proceso" NUMERIC,
    "Responsable" TEXT
) AS $$
BEGIN
    RETURN QUERY
    WITH LoteSeleccionado AS (
        SELECT id_lote_producto 
        FROM LotesProducto 
        WHERE codigo = codigo_lote
    ),
    EtapasRecurrentes AS (
        SELECT 
            pr.numero_batch::TEXT,
            CASE 
                WHEN mz.id_proceso_recurrente IS NOT NULL THEN 'MEZCLADO'
                WHEN md.id_proceso_recurrente IS NOT NULL THEN 'MOLDEADO'
                WHEN s.id_proceso_recurrente IS NOT NULL THEN 'SECADO'
            END AS etapa,
            pr.estado::TEXT,
            pr.fecha_proceso,
            pr.tiempo_proceso::NUMERIC,
            COALESCE(mz.id_empleado, md.id_empleado, s.id_empleado) AS id_empleado
        FROM ProcesosRecurrente pr
        LEFT JOIN Mezclados mz ON pr.id_proceso_recurrente = mz.id_proceso_recurrente
        LEFT JOIN Moldeados md ON pr.id_proceso_recurrente = md.id_proceso_recurrente
        LEFT JOIN Secados s ON pr.id_proceso_recurrente = s.id_proceso_recurrente
        JOIN LoteSeleccionado l ON pr.id_lote_producto = l.id_lote_producto
    )

    -- DOSIFICADO
    SELECT 
        d.numero_batch::TEXT,
        'DOSIFICADO',
        d.estado::TEXT,
        d.fecha_proceso,
        (d.tiempo_proceso / 60)::NUMERIC,
        p.nombre::TEXT
    FROM Dosificados d
    JOIN Empleados e ON d.id_empleado = e.id_empleado
    JOIN Personas p ON e.id_empleado = p.id_persona
    JOIN LoteSeleccionado l ON d.id_lote_producto = l.id_lote_producto

    UNION ALL

    -- MEZCLADO, MOLDEADO, SECADO
    SELECT 
        er.numero_batch,
        er.etapa,
        er.estado,
        er.fecha_proceso,
        er.tiempo_proceso,
        p.nombre::TEXT
    FROM EtapasRecurrentes er
    JOIN Empleados e ON er.id_empleado = e.id_empleado
    JOIN Personas p ON e.id_empleado = p.id_persona

    UNION ALL

    -- ENVASADO
    SELECT 
        en.numero_batch::TEXT,
        'ENVASADO',
        en.estado::TEXT,
        en.fecha_proceso,
        (en.tiempo_proceso / 60)::NUMERIC,
        p.nombre::TEXT
    FROM Envasados en
    JOIN Empleados e ON en.id_empleado = e.id_empleado
    JOIN Personas p ON e.id_empleado = p.id_persona
    JOIN LoteSeleccionado l ON en.id_lote_producto = l.id_lote_producto;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insumos_dosificados_lote(codigo_lote TEXT)
RETURNS TABLE (
    "Tipo de Insumo" TEXT,
    "Nombre de Insumo" TEXT,
    "Lote" TEXT,
    "Cantidad Dosificada" NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        i.tipo_insumo::TEXT AS "Tipo de Insumo",
        i.nombre_insumo::TEXT AS "Nombre de Insumo",
        li.codigo::TEXT AS "Lote",
        dxli.cantidad_dosificada AS "Cantidad Dosificada"
    FROM Dosificados d
    JOIN LotesProducto lp ON d.id_lote_producto = lp.id_lote_producto
    JOIN OrdenesProduccion op ON lp.id_orden_produccion = op.id_orden_produccion
    JOIN SolicitudesProduccion sp ON op.id_solicitud_produccion = sp.id_solicitud_produccion
    JOIN Formulaciones f ON sp.id_producto = f.id_producto
    JOIN DetallesFormulacion df ON f.id_formulacion = df.id_formulacion
    JOIN Insumos i ON df.id_insumo = i.id_insumo
    JOIN LotesInsumo li ON li.id_insumo = i.id_insumo
        AND li.fecha_vencimiento >= d.fecha_proceso::DATE
    JOIN DosificadosXLotesInsumo dxli ON dxli.id_dosificado = d.id_dosificado
        AND dxli.id_lote_insumo = li.id_lote_insumo
    WHERE lp.codigo = codigo_lote;
END;
$$ LANGUAGE plpgsql;
```

## Módulo 2: Almacen de Insumos

### TRIGGERS 
Para la generación de códigos de forma automática en las tablas Recepciones y Abastecimientos.

```sql
--Abastecimientos de Insumos
CREATE OR REPLACE FUNCTION crear_abastecimiento_automatico()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO abastecimientos (codigo, id_orden_produccion)
    VALUES (
        generar_codigo_abastecimiento_insumos(),
        NEW.id_orden_produccion
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_crear_abastecimiento
AFTER INSERT ON ordenesproduccion
FOR EACH ROW
EXECUTE FUNCTION crear_abastecimiento_automatico();

--Recepcion de Insumos
CREATE OR REPLACE FUNCTION crear_recepciones_automatico()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO recepciones (codigo, id_compra)
    VALUES (
        generar_codigo_recepcion_insumos(),
        NEW.id_compra
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_crear_recepciones
AFTER INSERT ON compras
FOR EACH ROW
EXECUTE FUNCTION crear_recepciones_automatico();
```

## Módulo 3: Control de Calidad

## Enumerados utilizados

### 1. `estado_revision_enum`
```sql
CREATE TYPE estado_revision_enum AS ENUM ('Aprobado', 'Rechazado', 'Pendiente');
```

### 2. `tipo_fallo_enum`
```sql
CREATE TYPE tipo_fallo_enum AS ENUM ('Humano', 'Maquina');
```

### 3. `tipo_inspeccion_enum`
```sql
CREATE TYPE tipo_inspeccion_enum AS ENUM ('Lote de Insumo', 'Proceso', 'Envasado', 'Picking');
```

**Justificación**: Los enumerados permiten validación, estandarización y mejor filtrado en formularios y vistas.


## Módulo 4: Compras

### Objeto 1: estado_compra_enum

* **Tipo:** `ENUM`

* **Valores:** `'PEN'` (pendiente), `'APR'` (aprobada), `'REC'` (recibida), `'ANU'` (anulada)

* **Tablas asociadas:** `Compras`

* **Justificación:** Define los estados clave del ciclo de vida de una compra, permitiendo realizar seguimientos, validaciones y filtros precisos en reportes y procesos automáticos.

* **SQL:**

```sql
CREATE TYPE estado_compra_enum AS ENUM (
  'PEN',  -- pendiente
  'APR',  -- aprobada
  'REC',  -- recibida
  'ANU'   -- anulada
);
```
### Objeto 2: estado_seguimiento_compra_enum

* **Tipo:** `ENUM`

* **Valores:** `'ENV'` (enviado), `'REC'` (recibido), `'DEM'` (demorado), `'ENT'` (entregado)

* **Tablas asociadas:** `SeguimientosCompra`

* **Justificación:** Establece las etapas clave del seguimiento de una compra, lo que permite reflejar en tiempo real el estado logístico y detectar incidentes de entrega.

* **SQL:**

```sql
CREATE TYPE estado_seguimiento_compra_enum AS ENUM (
  'ENV',  -- enviado
  'REC',  -- recibido
  'DEM',  -- demorado
  'ENT'   -- entregado
);
```

### Objeto 3: estado_notificacion_reclamo_enum

* **Tipo:** `ENUM`

* **Valores:** `'PEN'` (pendiente), `'REV'` (revisado), `'DER'` (derivado), `'CERR'` (cerrado)

* **Tablas asociadas:** `NotificacionesReclamo`

* **Justificación:** Controla el ciclo de atención de notificaciones de reclamos, ayudando a identificar qué reclamos requieren atención y su estado en la gestión de calidad.

* **SQL:**

```sql
CREATE TYPE estado_notificacion_reclamo_enum AS ENUM (
  'PEN',   -- pendiente
  'REV',   -- revisado
  'DER',   -- derivado
  'CERR'   -- cerrado
);
```

### TRIGGERS 

## Módulo 6: Distribución

Para la generación de códigos de forma automática en las tablas ProgramacionesDespacho y OrdenesCarga

```sql
-- Programaciones de despacho
CREATE FUNCTION registrar_codigo_prog_desp()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.codigo IS NULL THEN
        NEW.codigo := generar_codigo_prog_desp();
    END IF;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER antes_registro_prog_desp
BEFORE INSERT ON programacionesdespacho
FOR EACH ROW
EXECUTE FUNCTION registrar_codigo_prog_desp();

-- Ordenes de carga
CREATE FUNCTION registrar_codigo_ord_carga()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.codigo IS NULL THEN
        NEW.codigo := generar_codigo_ord_carga();
    END IF;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER antes_registro_ord_carga
BEFORE INSERT ON ordenescarga
FOR EACH ROW
EXECUTE FUNCTION registrar_codigo_ord_carga();
```
